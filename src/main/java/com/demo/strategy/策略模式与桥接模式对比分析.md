# 策略模式与桥接模式对比分析

## 1. 相似之处：为什么容易混淆？

### 1.1 结构相似性
```java
// 策略模式结构 - 行为型
Context ──组合──> Strategy Interface
                  △
                  ├── ConcreteStrategyA
                  ├── ConcreteStrategyB
                  └── ConcreteStrategyC
```
以本包下的 demo 为例
并不一定要有两个系列的产品，同时一个聚合进入另一个，而是需要这样的结构：在这个 Context（Book） 中，
需要**聚合**（**持有引用**）作为策略的 DiscountStrategy 的实现类，但是更多依赖的不是“利用五花八门的 DiscountStrategy 来创建 Book 对象”，
而是针对同一个 Book 对象，选定他将要聚合的 DiscountStrategy 实现类，并且 Context（Book） 本身的其他方法，是强烈依赖于**他所聚合的 DiscountStrategy** 的原生方法的，
所以表现出来就是**行为型**，Context（Book）聚合不同 DiscountStrategy 的核心需求，就是等价于聚合了**不同的算法**

```java
// 桥接模式 - 结构型
Abstraction ──组合──> Implementor Interface
                      △
                      ├── ConcreteImplementorA
                      ├── ConcreteImplementorB
                      └── ConcreteImplementorC
```
以 bridge 包下 demo 为例：
相同点也是一个系列的产品，**聚合**（即：**持有引用**）了另一个系列的产品
侧重在创建**不同** Coffee 对象的时候，通过“**组合**”的方式，与**不同**的 Additives 进行结合，得到**新对象**

### 1.2 共同特征
1. **都有组合关系**：都通过接口组合实现灵活性
2. **都实现运行时变化**：都可以在运行时切换具体实现
3. **都遵循"组合优于继承"**：避免了类爆炸问题
4. **都有接口隔离**：都将变化部分抽象成接口

## 2. 核心区别：本质差异分析

### 2.1 抽象维度不同

**策略模式**：
- **只有一层抽象维度**：Strategy接口层
- Context层没有抽象，是具体类
- 关注点：算法/行为的选择

```java
// Context是具体类，没有抽象层
public class Book {
    private DiscountStrategy strategy;  // 只有一层抽象

    public double calculateFinalPrice() {
        return strategy.calculateDiscount(originalPrice);  // 委托给策略
    }
}
```

**桥接模式**：
- **两层抽象维度**：Abstraction抽象层 + Implementor接口层
- 两个抽象层次可以独立变化
- 关注点：抽象与实现的分离

```java
// 两个抽象层次
public abstract class Coffee {  // 第一层抽象
    protected CoffeeAdditives additives;  // 第二层抽象

    public abstract String getDescription();
}

public interface CoffeeAdditives {  // 第二层抽象接口
    String addSomething();
}
```

### 2.2 目的不同

**策略模式**：
- **目的**：行为选择
- **侧重点**：给Context注入不同的策略实现类，让Context具有不同的"行为"
- **本质**：Context内部调用自己持有的策略对象的具体方法

```java
// 策略模式：关注行为的切换
book.setStrategy(new ComputerBookDiscountStrategy());  // 注入行为
double price = book.calculateFinalPrice();  // 表现不同的计算行为
```

**桥接模式**：
- **目的**：结构分离，通过组合创建不同对象
- **侧重点**：两个维度的自由组合
- **本质**：将抽象部分与实现部分分离，使它们都可以独立变化

```java
// 桥接模式：关注结构的组合
Coffee coffee = new MediumCoffee();  // 抽象层：尺寸维度
coffee.setAdditives(new Milk());     // 实现层：配料维度
// 结果：中杯咖啡+牛奶的组合
```

### 2.3 对象创建方式不同

**策略模式**：
- **对象创建**：所有对象基本都是直接new出来的
- **使用方式**：注入策略，获得不同行为
- **关注点**：行为的变化

```java
// 策略模式：直接new策略对象
DiscountStrategy strategy = new ComputerBookDiscountStrategy();
Book book = new Book("Java编程思想", 89.00, strategy);
// 关注：book有了计算机书的折扣行为
```

**桥接模式**：
- **对象创建**：通过组合两个抽象层次创建复合对象
- **使用方式**：不同维度的对象组合
- **关注点**：对象结构的多样性

```java
// 桥接模式：组合两个维度的对象
Coffee coffee1 = new SmallCoffee(new Sugar());   // 小杯+糖
Coffee coffee2 = new MediumCoffee(new Milk());   // 中杯+牛奶
Coffee coffee3 = new JorumCoffee(new Lemon());   // 大杯+柠檬
// 关注：创建了3种不同结构的咖啡对象
```

## 3. 实际项目对比

### 3.1 策略模式实现（书籍折扣）
```java
// 策略接口：一种抽象维度
public interface DiscountStrategy {
    double calculateDiscount(double originalPrice);
}

// Context：没有抽象层
public class Book {
    private String title;
    private double originalPrice;
    private DiscountStrategy strategy;  // 持有策略对象

    public double calculateFinalPrice() {
        return strategy.calculateDiscount(originalPrice);  // 调用策略方法
    }
}

// 使用：注入不同策略，获得不同行为
Book computerBook = new Book("Java", 89, new ComputerBookDiscountStrategy());
Book englishBook = new Book("英语", 45, new EnglishBookDiscountStrategy());
// 两本书具有不同的折扣计算行为
```

### 3.2 桥接模式实现（咖啡店）
```java
// 两个抽象维度
public abstract class Coffee {  // 第一层：咖啡抽象
    protected CoffeeAdditives additives;  // 第二层：配料实现

    public abstract String getDescription();
}

public interface CoffeeAdditives {  // 第二层抽象：配料接口
    String addSomething();
}

// 使用：组合两个维度，创建不同结构
Coffee coffee1 = new SmallCoffee(new Sugar());   // 小杯糖咖啡
Coffee coffee2 = new MediumCoffee(new Milk());   // 中杯牛奶咖啡
Coffee coffee3 = new JorumCoffee(new Lemon());   // 大杯柠檬咖啡
// 三种不同结构的咖啡对象（3种尺寸 × 3种配料 = 9种组合）
```

## 4. 选择原则

### 4.1 使用策略模式的情况
1. **需要在不同算法间切换**
2. **一个类有多种行为变体**
3. **需要在运行时选择算法**
4. **避免使用多重条件语句**

典型场景：
- 价格计算（不同折扣策略）
- 数据排序（不同排序算法）
- 路线规划（不同路径算法）

### 4.2 使用桥接模式的情况
1. **一个类存在多个独立变化的维度**
2. **需要在多个维度上独立扩展**
3. **不希望使用继承导致类爆炸**
4. **需要共享实现细节**

典型场景：
- GUI工具包（窗口系统×组件）
- 跨平台应用（平台×功能）
- 产品配置（型号×配件）

## 5. 记忆技巧

### 5.1 关键记忆点
- **策略模式**："行为选择"，注入策略获得不同行为
- **桥接模式**："结构组合"，组合维度获得不同对象

### 5.2 一句话区分
> 策略模式关注**"怎么做"**（行为），桥接模式关注**"是什么"**（结构）

### 5.3 使用场景判断
- 如果想改变**行为方式** → 策略模式
- 如果想改变**对象结构** → 桥接模式

## 6. 总结

策略模式和桥接模式虽然结构相似，但本质不同：

1. **抽象维度**：策略模式一层，桥接模式两层
2. **关注点**：策略模式关注行为选择，桥接模式关注结构组合
3. **对象创建**：策略模式直接new对象获得行为，桥接模式组合对象获得结构
4. **使用目的**：策略模式改变行为，桥接模式改变结构

理解这些差异，就能在实际项目中正确选择和应用这两种模式了。