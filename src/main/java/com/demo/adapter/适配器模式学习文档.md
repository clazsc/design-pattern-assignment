# 适配器模式学习文档

## 模式概述

适配器模式（Adapter Pattern）是一种结构型设计模式，它允许接口不兼容的类能够相互合作。适配器模式就像现实中的电源适配器一样，能够让不同的插头和插座配合工作。

## 核心概念

- **目标接口（Target）**：客户端所期待的接口，在示例中是 `Shape` 接口
- **适配者（Adaptee）**：需要被适配的、已经存在的类，在示例中是 `Angle` 类
- **适配器（Adapter）**：将适配者接口转换成目标接口的类，在示例中是 `AngleAdapter`

## 模式结构

### 类图关系

```
Target (Shape)
    ▲
    │ implements
    │
Adapter (AngleAdapter)
    ▲
    │ contains
    │
Adaptee (Angle)
```

## 代码示例分析

### 1. 目标接口 - Shape

```java
public interface Shape {
    void Draw();  // 统一的绘制方法
}
```

**作用**：定义绘图系统的标准接口，所有图形都应该实现这个接口。

### 2. 符合目标接口的类

```java
public class Circle implements Shape {
    @Override
    public void Draw() {
        System.out.println("正在绘制圆形");
    }
}
```

**特点**：
- 直接实现目标接口
- 无需适配即可使用
- 包括：Circle、Rectangle、Line

### 3. 需要适配的遗留类 - Angle

```java
public class Angle {
    public void DrawAngle() {  // 注意：方法名不是Draw()，这是一个不兼容的方法
        System.out.println("正在绘制角度");
    }
}
```

**问题**：
- 接口不兼容（方法名不一致）
- 无法直接在绘图系统中使用
- 但功能是符合需求的

### 4. 适配器 - AngleAdapter

```java
public class AngleAdapter implements Shape {
    private final Angle angle;

    public AngleAdapter(Angle angle) {
        this.angle = angle;
    }

    @Override
    public void Draw() {
        System.out.print("适配器工作：将 Draw() 调用转换为 -> ");
        angle.DrawAngle();  // 调用适配者的方法
    }
}
```

**核心作用**：
- 实现目标接口（Shape）
- 持有适配者对象（Angle）
- 在目标接口方法中调用适配者的对应方法

### 5. 客户端使用 - DrawingSystem

```java
List<Shape> shapes = new ArrayList<>();

// 添加符合接口的图形
shapes.add(new Circle());
shapes.add(new Rectangle());
shapes.add(new Line());

// 通过适配器添加不兼容的图形
Angle legacyAngle = new Angle();
Shape adaptedAngle = new AngleAdapter(legacyAngle);
shapes.add(adaptedAngle);

// 统一调用，无需区分
for (Shape shape : shapes) {
    shape.Draw();
}
```

## 运行结果

```
开始统一绘制所有图形...
正在绘制圆形 (调用 Draw() 方法)...
正在绘制矩形 (调用 Draw() 方法)...
正在绘制线条 (调用 Draw() 方法)...
适配器工作：将 Draw() 调用转换为 -> 正在绘制角度 (调用 DrawAngle() 方法)...
```

## 模式优势

1. **接口统一**：让不兼容的接口能够协同工作
2. **复用性**：复用现有功能，无需修改原有代码
3. **解耦合**：客户端代码与具体实现解耦
4. **扩展性**：可以方便地添加新的适配器

## 适用场景

1. **集成遗留系统**：需要使用已有的、接口不兼容的类
2. **统一接口**：希望用统一的接口处理多个不同的类
3. **第三方库集成**：第三方库的接口与系统接口不匹配
4. **接口升级**：旧版本的接口需要在新系统中使用

## 适配器模式类型

### 对象适配器（本示例采用）
- 通过组合方式持有适配者对象
- 更灵活，可以适配多个适配者
- 符合合成复用原则

### 类适配器
- 通过继承方式实现适配
- 需要多重继承支持
- 耦合度较高

## 实际应用场景

1. **数据库驱动**：不同数据库的驱动适配到统一的JDBC接口
2. **日志框架**：将各种日志系统适配到统一的日志接口
3. **支付网关**：不同的第三方支付平台适配到统一的支付接口
4. **消息队列**：不同的消息中间件适配到统一的消息接口

## 最佳实践

1. **优先使用对象适配器**：更灵活，耦合度更低
2. **保持接口一致性**：适配器应该完全实现目标接口
3. **适当添加日志**：便于调试适配过程
4. **考虑性能开销**：适配器会增加一层调用开销

## 总结

适配器模式是解决接口不兼容问题的有效方案。通过引入适配器层，可以让原本无法协同工作的类能够无缝集成，同时保持原有代码的完整性和复用性。这种模式在实际开发中非常常见，特别是在系统集成和第三方库使用场景中。