# 抽象工厂模式学习文档

## 1. 模式定义

抽象工厂模式（Abstract Factory Pattern）是一种创建型设计模式，它提供了一个接口，用于创建一系列相关或相互依赖的对象，而无需指定它们具体的类。

## 2. 核心概念

### 2.1 产品族（Product Family）
产品族是指一系列相关的产品，这些产品通常属于同一个主题或品牌。比如：
- KFC产品族：KFC汉堡 + KFC可乐
- McDonald's产品族：Mc汉堡 + Mc可乐

### 2.2 抽象工厂（Abstract Factory）
定义创建一系列产品的抽象方法的接口，每个方法对应产品族中的一个产品类型。

## 3. 与工厂方法模式的核心区别

| 特征 | 工厂方法模式 | 抽象工厂模式 |
|------|-------------|-------------|
| **顶层工厂接口** | 只有一个创建方法 | 有多个创建方法 |
| **产品数量** | 一种产品类型 | 多种产品类型 |
| **关注点** | 单一产品的创建 | 产品族的创建 |
| **复杂度** | 简单 | 复杂 |

### 3.1 代码对比

**工厂方法模式：**
```java
public interface VehicleFactory {
    Vehicle createVehicle(); // 只有一种产品
}
```

**抽象工厂模式：**
```java
public interface FastFoodFactory {
    Hamburg createHamburg(); // 产品类型1
    Cola createCola();       // 产品类型2
}
```

### 3.2 关系理解
- 抽象工厂 = 工厂方法的扩展
- 工厂方法 = 抽象工厂的特例（当产品族只有一个产品时）

## 4. 模式结构

### 4.1 核心角色

1. **AbstractFactory（抽象工厂）**
   - 声明创建抽象产品的方法
   - 一个工厂可以创建多个产品

2. **ConcreteFactory（具体工厂）**
   - 实现抽象工厂接口
   - 负责创建具体的产品族

3. **AbstractProduct（抽象产品）**
   - 定义产品族的共同接口
   - 每个产品类型都有一个抽象产品接口

4. **ConcreteProduct（具体产品）**
   - 实现抽象产品接口
   - 由具体工厂创建

### 4.2 UML结构图示例

```
┌─────────────────┐
│  FastFoodFactory│
│─────────────────┤
│+createHamburg() │
│+createCola()    │
└─────────────────┘
         △
         │
    ┌───────────────────────┐
    │   KFCFactory          │
    │   McDonaldsFactory    │
    └───────────────────────┘
```

## 5. 项目实现分析

### 5.1 目录结构
```
com.demo.abstractfactory/
├── factory/
│   ├── FastFoodFactory.java        # 抽象工厂接口
│   └── impl/
│       ├── KFCFactory.java         # KFC具体工厂
│       └── McDonaldsFactory.java   # McDonald's具体工厂
├── hamburg/
│   ├── Hamburg.java                # 抽象汉堡产品
│   └── impl/
│       ├── KFCHamburg.java         # KFC汉堡具体产品
│       └── McDonaldsHamburg.java   # McDonald's汉堡具体产品
├── cola/
│   ├── Cola.java                   # 抽象可乐产品
│   └── impl/
│       ├── KFCCola.java           # KFC可乐具体产品
│       └── McDonaldsCola.java     # McDonald's可乐具体产品
├── Client.java                     # 客户端演示
└── FastFoodRestaurant.java         # 业务场景演示
```

### 5.2 核心代码实现

**抽象工厂接口：**
```java
public interface FastFoodFactory {
    Hamburg createHamburg();
    Cola createCola();
}
```

**具体工厂实现（以KFC为例）：**
```java
public class KFCFactory implements FastFoodFactory {
    @Override
    public Hamburg createHamburg() {
        return new KFCHamburg();
    }

    @Override
    public Cola createCola() {
        return new KFCCola();
    }
}
```

### 5.3 业务场景
快餐店点餐系统，确保同一品牌的套餐一致性：
- 点KFC套餐：KFC汉堡 + KFC可乐
- 点McDonald's套餐：Mc汉堡 + Mc可乐

## 6. 模式优势

### 6.1 优势
1. **产品族一致性**：确保同一工厂创建的产品相互兼容
2. **解耦**：客户端与具体产品类解耦
3. **易于扩展**：新增产品族只需添加新的具体工厂
4. **符合开闭原则**：对扩展开放，对修改关闭

### 6.2 劣势
1. **扩展产品类型困难**：新增产品类型需要修改所有工厂接口
2. **复杂性增加**：比工厂方法模式更复杂
3. **抽象层次增加**：理解和使用成本较高

## 7. 适用场景

### 7.1 适用条件
1. 需要创建的对象是一系列相互关联或相互依赖的产品族
2. 系统需要独立于产品的创建、组合和表示
3. 系统要求提供多个产品族，但每次只使用其中一个产品族
4. 产品等级结构稳定，不会频繁新增产品类型

### 7.2 实际应用场景
1. **UI主题切换**：Windows主题 vs macOS主题
2. **数据库访问**：MySQL组件族 vs Oracle组件族
3. **游戏开发**：不同阵营的单位和建筑
4. **跨平台开发**：不同操作系统的UI组件

## 8. 扩展性问题

### 8.1 新增产品族（容易）
```java
// 新增一个Burger King产品族
public class BurgerKingFactory implements FastFoodFactory {
    @Override
    public Hamburg createHamburg() {
        return new BKHamburger();
    }

    @Override
    public Cola createCola() {
        return new BKCola();
    }
}
```

### 8.2 新增产品类型（困难）
如果要新增"薯条"产品，需要：
1. 修改`FastFoodFactory`接口，添加`createFrenchFries()`方法
2. 修改所有具体工厂实现类，实现新的方法
3. 添加所有具体薯条产品类

## 9. 总结

抽象工厂模式是工厂方法模式的自然扩展，核心区别在于：

1. **工厂方法模式**：关注单一产品的创建，一个工厂只生产一种产品
2. **抽象工厂模式**：关注产品族的创建，一个工厂生产系列产品

抽象工厂模式通过产品族的概念，确保了同一品牌/系列产品的完整性和一致性，是解决复杂产品体系创建问题的有效方案。

### 关键理解点
- 抽象工厂 = 工厂方法的扩展
- 工厂方法 = 抽象工厂的特例
- 产品族是抽象工厂的核心概念
- 扩展产品族容易，扩展产品类型困难