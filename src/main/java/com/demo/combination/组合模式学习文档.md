# 组合模式（Composite Pattern）学习文档

## 模式概述

组合模式是一种结构型设计模式，它将对象组合成树形结构以表示"部分-整体"的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。

### 核心思想
1. **树形结构**：将对象组织成树形层次结构
2. **统一接口**：客户端可以用相同的方式处理单个对象和组合对象
3. **递归操作**：通过递归实现对整个树结构的统一操作

## 模式结构

### 角色定义
- **抽象组件(Component)**：定义叶子节点和容器节点的共同接口
- **叶子节点(Leaf)**：表示树形结构中的叶子对象，没有子节点
- **容器节点(Composite)**：表示可以包含子节点的复合对象
- **客户端(Client)**：通过组件接口操作组合对象

### UML结构
```
Component (抽象组件)
├── Leaf (叶子节点)
└── Composite (容器节点)
    └── Component... (可以包含多个子组件)
```

## 实际应用案例

### 案例1：系统管理菜单（MenuSystem）

#### 场景描述
实现系统管理中的多级菜单结构，包括菜单管理、权限配置、角色管理等模块。

#### 结构设计
```
MenuComponent (抽象组件)
├── MenuItem (叶子节点 - 具体菜单项)
└── Menu (容器节点 - 菜单分类)
```

#### 代码实现要点
```java
// 抽象组件
public abstract class MenuComponent {
    protected String name;
    protected int level;

    public void print() {
        for (int i = 0; i < level; i++) {
            System.out.print("  ");
        }
        System.out.println(getDisplayInfo());
    }

    // 统一的接口方法
    public void add(MenuComponent component) {
        throw new UnsupportedOperationException("叶子节点不支持添加操作");
    }
}

// 叶子节点
public class MenuItem extends MenuComponent {
    @Override
    protected String getDisplayInfo() {
        return "- " + name;
    }
}

// 容器节点
public class Menu extends MenuComponent {
    private List<MenuComponent> children = new ArrayList<>();

    @Override
    public void print() {
        super.print(); // 显示自己
        for (MenuComponent child : children) {
            child.print(); // 递归显示子节点
        }
    }
}
```

#### 实际效果
```
+ 系统管理
  + 菜单管理
    - 页面访问
    - 展开菜单
    - 编辑菜单
    - 删除菜单
    - 新增菜单
  + 权限配置
    - 页面访问
    - 提交保存
  + 角色管理
    - 页面访问
    - 新增角色
    - 修改角色
```

### 案例2：文件目录系统（FileSystem）

#### 场景描述
模拟计算机的文件系统结构，实现类似Linux/Windows的tree命令效果。

#### 结构设计
```
FileComponent (抽象组件)
├── File (叶子节点 - 具体文件)
└── Directory... (容器节点 - 目录)
```

#### 代码实现要点
```java
// 抽象组件
public abstract class FileComponent {
    protected String name;
    protected int depth;

    public void print() {
        for (int i = 0; i < depth; i++) {
            System.out.print("--");
        }
        System.out.println(name);
    }
}

// 叶子节点（文件）
public class File extends FileComponent {
    private long size;

    @Override
    public void print() {
        for (int i = 0; i < depth; i++) {
            System.out.print("--");
        }
        if (size > 0) {
            System.out.println(name + " (" + size + " bytes)");
        } else {
            System.out.println(name);
        }
    }
}

// 容器节点（目录）
public class Directory extends FileComponent {
    private List<FileComponent> children = new ArrayList<>();

    @Override
    public void print() {
        for (int i = 0; i < depth; i++) {
            System.out.print("--");
        }
        if (name.equals("/")) {
            System.out.println(name); // 根目录
        } else {
            System.out.println(name.isEmpty() ? name : name + "/");
        }

        for (FileComponent child : children) {
            child.print(); // 递归显示所有子节点
        }
    }
}
```

#### 实际效果
```
/
--home/
----user1/
------document.txt (1024 bytes)
------photo.jpg (2048 bytes)
----user2/
------documents/
--------report.pdf (3072 bytes)
--usr/
----bin/
------ls (65536 bytes)
--var/
----log/
------system.log (25600 bytes)
```

## 模式优势

### 1. 统一接口
- 客户端可以一致地处理单个对象和组合对象
- 不需要区分处理叶子节点和容器节点
- 简化客户端代码

### 2. 灵活性
- 可以轻松添加新的组件类型
- 支持动态构建复杂的树形结构
- 易于维护和扩展

### 3. 层次结构清晰
- 明确表达"部分-整体"的层次关系
- 代码结构直观，易于理解

### 4. 递归操作
- 通过递归实现整个树结构的统一操作
- 代码简洁，避免复杂的遍历逻辑

## 实际应用场景

### 1. GUI框架
- **Java Swing菜单**：JMenuBar、JMenu、MenuItem
- **Web前端**：DOM树结构，父子节点关系
- **移动端**：UI组件树的构建和渲染

### 2. 文件系统
- **操作系统**：目录和文件的层次结构
- **压缩软件**：压缩包内的文件树
- **云存储**：文件夹和文件的组织结构

### 3. 组织架构
- **企业管理系统**：部门-员工层级关系
- **权限系统**：角色-权限的树形结构
- **分类管理**：商品分类、文章分类等

### 4. 其他场景
- **XML/JSON解析**：文档树的构建和遍历
- **编译器**：语法树的构建
- **游戏开发**：场景对象的管理

## 设计要点

### 1. 组件接口设计
- 提供统一的操作接口
- 在抽象组件中定义所有子类共有的方法
- 对于叶子节点不支持的操，抛出UnsupportedOperationException

### 2. 递归实现
- 容器节点的操作方法通常需要递归处理子节点
- 合理控制递归深度，避免栈溢出
- 考虑性能影响，对大型结构进行优化

### 3. 安全性考虑
- 叶子节点的add、remove等操作需要适当的异常处理
- 确保组件类型的安全性检查
- 防止循环引用导致的无限递归

### 4. 扩展性设计
- 预留扩展接口，支持新增组件类型
- 考虑添加遍历器、访问者等模式支持
- 支持序列化/反序列化功能

## 总结

组合模式是处理树形结构的经典设计模式，它通过将对象组织成层次结构，实现了对单个对象和组合对象的统一处理。通过系统管理菜单和文件目录两个实际案例，我们可以看到组合模式在现实软件开发中的广泛应用。

**核心价值**：
- 简化客户端代码
- 提高代码复用性
- 增强系统灵活性
- 清晰表达层次关系

**适用场景**：
- 需要处理树形结构的场景
- 希望统一处理组合对象和单个对象
- 需要动态构建复杂结构的系统

掌握组合模式对于构建层次化的软件系统具有重要意义，是软件设计中的重要工具。